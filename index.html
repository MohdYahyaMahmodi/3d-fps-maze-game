<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D FPS GAME</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            width: 100%;
            color: #ffffff;
            text-align: center;
            top: 10px;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
        #scoreboard {
            position: absolute;
            width: 200px;
            color: #ffffff;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
    </style>
</head>
<body>

<div id="info">Click to play. Use W/A/S/D to move, mouse to look, and left-click to shoot.</div>
<div id="scoreboard">Round: 1<br>Enemies Remaining: 0</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // Basic setup
    let scene, camera, renderer;
    let controlsEnabled = false;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();

    // Player setup
    let raycaster;
    const bullets = [];
    let gun;

    // Enemy and Wave Management
    const enemies = [];
    let round = 1;
    let enemiesRemaining = 0;
    let waveInProgress = false;

    // Movement variables
    const moveSpeed = 200.0;
    const lookSpeed = 0.002;

    // Initialize the scene
    init();
    animate();

    function init() {
        // Scene and Camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x808080); // Grey background
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 50, 0);
        scene.add(directionalLight);

        // Room (Box Geometry)
        const roomSize = 500;
        const roomGeometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
        const roomMaterials = [
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide }), // Left
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide }), // Right
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide }), // Top
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide }), // Bottom
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide }), // Front
            new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.BackSide })  // Back
        ];
        const room = new THREE.Mesh(roomGeometry, roomMaterials);
        scene.add(room);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -roomSize / 2;
        scene.add(floor);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        document.addEventListener('click', function () {
            if (!controlsEnabled) {
                document.body.requestPointerLock();
            }
        }, false);

        document.addEventListener('pointerlockchange', lockChange, false);

        function lockChange() {
            if (document.pointerLockElement === document.body) {
                controlsEnabled = true;
                document.getElementById('info').style.display = 'none';
            } else {
                controlsEnabled = false;
                document.getElementById('info').style.display = '';
            }
        }

        // Mouse controls
        const onMouseMove = function (event) {
            if (controlsEnabled) {
                camera.rotation.y -= event.movementX * lookSpeed;
                camera.rotation.x -= event.movementY * lookSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        };
        document.addEventListener('mousemove', onMouseMove, false);

        // Keyboard controls
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        // Shooting
        document.addEventListener('mousedown', function (event) {
            if (event.button === 0 && controlsEnabled) { // Left-click
                shoot();
            }
        }, false);

        // Raycaster for shooting
        raycaster = new THREE.Raycaster();

        // Player's Gun
        createGun();

        // Start the first wave
        startWave();

        // Window resize
        window.addEventListener('resize', onWindowResize, false);

        // Set initial camera position
        camera.position.set(0, 10, 0); // Start slightly above the floor
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (controlsEnabled) {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * moveSpeed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * moveSpeed * delta;

            // Move the camera (player)
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.extractRotation(camera.matrix);
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyMatrix4(rotationMatrix);
            const sideways = new THREE.Vector3(-1, 0, 0);
            sideways.applyMatrix4(rotationMatrix);

            camera.position.add(forward.multiplyScalar(velocity.z * delta));
            camera.position.add(sideways.multiplyScalar(velocity.x * delta));

            // Keep the player inside the room
            const roomLimit = 200;
            camera.position.x = THREE.MathUtils.clamp(camera.position.x, -roomLimit, roomLimit);
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, -roomLimit, roomLimit);

            // Keep the camera above the floor
            camera.position.y = 10;

            // Update gun position
            updateGunPosition();

            prevTime = time;

            // Update enemies
            updateEnemies(delta);

            // Update bullets
            updateBullets(delta);

            // Check if wave is completed
            if (enemiesRemaining <= 0 && !waveInProgress) {
                waveInProgress = true;
                setTimeout(() => {
                    round++;
                    startWave();
                    waveInProgress = false;
                }, 2000); // 2 seconds delay before next wave
            }
        }

        renderer.render(scene, camera);
    }

    function createGun() {
        const gunGeometry = new THREE.BoxGeometry(2, 2, 8);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
        gun = new THREE.Mesh(gunGeometry, gunMaterial);
        scene.add(gun);
    }

    function updateGunPosition() {
        // Position the gun in front of the camera
        gun.position.copy(camera.position);
        gun.rotation.copy(camera.rotation);

        const gunOffset = new THREE.Vector3(0.5, -1, -2);
        gunOffset.applyQuaternion(camera.quaternion);
        gun.position.add(gunOffset);
    }

    function startWave() {
        enemiesRemaining = 0;
        const enemiesToSpawn = 4 + (round - 1) * 2; // Increase enemy count each round
        for (let i = 0; i < enemiesToSpawn; i++) {
            spawnEnemy();
        }
        document.getElementById('scoreboard').innerHTML = `Round: ${round}<br>Enemies Remaining: ${enemiesRemaining}`;
    }

    function spawnEnemy() {
        const enemy = createEnemy();

        const roomLimit = 200;
        const minDistance = 100; // Minimum distance from player
        let spawnPosition = new THREE.Vector3();

        do {
            spawnPosition.x = Math.random() * roomLimit * 2 - roomLimit;
            spawnPosition.z = Math.random() * roomLimit * 2 - roomLimit;
            spawnPosition.y = 0;
        } while (spawnPosition.distanceTo(camera.position) < minDistance);

        enemy.position.copy(spawnPosition);

        enemies.push(enemy);
        scene.add(enemy);
        enemiesRemaining++;
        document.getElementById('scoreboard').innerHTML = `Round: ${round}<br>Enemies Remaining: ${enemiesRemaining}`;
    }

    function createEnemy() {
        const enemy = new THREE.Group();

        // Torso
        const torsoGeometry = new THREE.BoxGeometry(10, 15, 5);
        const torsoMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
        torso.position.y = 15;
        enemy.add(torso);

        // Head
        const headGeometry = new THREE.BoxGeometry(8, 8, 8);
        const headMaterial = new THREE.MeshBasicMaterial({ color: 0xffcccc });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 28;
        enemy.add(head);

        // Arms
        const armGeometry = new THREE.BoxGeometry(3, 15, 3);
        const armMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-7, 15, 0);
        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(7, 15, 0);
        enemy.add(leftArm);
        enemy.add(rightArm);

        // Legs
        const legGeometry = new THREE.BoxGeometry(4, 15, 4);
        const legMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-3, 0, 0);
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(3, 0, 0);
        enemy.add(leftLeg);
        enemy.add(rightLeg);

        return enemy;
    }

    function updateEnemies(delta) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            const direction = new THREE.Vector3();
            direction.subVectors(camera.position, enemy.position).normalize();
            enemy.position.add(direction.multiplyScalar(20 * delta));

            // Simple collision detection with player
            if (enemy.position.distanceTo(camera.position) < 10) {
                alert('Game Over!');
                window.location.reload();
            }
        }
    }

    function shoot() {
        const bulletGeometry = new THREE.SphereGeometry(1, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Start bullet from gun's tip
        const bulletPosition = new THREE.Vector3(0, -1, -4); // Slightly in front of the gun
        bulletPosition.applyQuaternion(camera.quaternion);
        bullet.position.copy(camera.position).add(bulletPosition);

        const vector = new THREE.Vector3(0, 0, -1);
        vector.applyQuaternion(camera.quaternion);
        bullet.userData.velocity = vector.clone().multiplyScalar(500);

        bullets.push(bullet);
        scene.add(bullet);
    }

    function updateBullets(delta) {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

            // Remove bullet if it's too far
            if (bullet.position.distanceTo(camera.position) > 1000) {
                scene.remove(bullet);
                bullets.splice(i, 1);
                continue;
            }

            // Check for collision with enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                if (bullet.position.distanceTo(enemy.position) < 5) {
                    scene.remove(enemy);
                    enemies.splice(j, 1);
                    enemiesRemaining--;
                    document.getElementById('scoreboard').innerHTML = `Round: ${round}<br>Enemies Remaining: ${enemiesRemaining}`;
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    break;
                }
            }
        }
    }
</script>

</body>
</html>
